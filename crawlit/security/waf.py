#!/usr/bin/env python3
"""
waf.py - Web Application Firewall detection

Detects various WAF solutions and provides evasion recommendations.
"""

import re
import logging
from typing import Dict, List, Optional, Set, Any
from enum import Enum
from dataclasses import dataclass

logger = logging.getLogger(__name__)


class WAFType(Enum):
    """Known WAF types"""
    CLOUDFLARE = "Cloudflare"
    AWS_WAF = "AWS WAF"
    AKAMAI = "Akamai"
    INCAPSULA = "Incapsula/Imperva"
    MODSECURITY = "ModSecurity"
    F5_BIG_IP = "F5 BIG-IP ASM"
    BARRACUDA = "Barracuda"
    FORTIWEB = "FortiWeb"
    CITRIX_NETSCALER = "Citrix NetScaler"
    RADWARE = "Radware AppWall"
    SUCURI = "Sucuri CloudProxy"
    WORDFENCE = "Wordfence"
    CLOUDFRONT = "Amazon CloudFront"
    AZURE_WAF = "Azure WAF"
    SQREEN = "Sqreen"
    REBLAZE = "Reblaze"
    WALLARM = "Wallarm"
    UNKNOWN = "Unknown WAF"
    NONE = "No WAF Detected"


@dataclass
class WAFDetectionResult:
    """Result of WAF detection"""
    detected: bool
    waf_type: WAFType
    confidence: float  # 0.0 to 1.0
    indicators: List[str]
    recommendations: List[str]
    headers: Dict[str, str]
    cookies: List[str]


class WAFDetector:
    """
    Detects Web Application Firewalls by analyzing HTTP responses.
    
    Uses multiple detection methods:
    - HTTP headers
    - Cookies
    - Response body patterns
    - Server behavior
    """
    
    # WAF signatures - headers, cookies, and patterns
    WAF_SIGNATURES = {
        WAFType.CLOUDFLARE: {
            'headers': ['cf-ray', 'cf-request-id', '__cfduid', 'cf-cache-status'],
            'cookies': ['__cfduid', '__cflb', '__cfwaitingroom'],
            'server': ['cloudflare'],
            'body_patterns': [
                r'cloudflare',
                r'checking your browser',
                r'ray id:',
                r'cf-error-details'
            ]
        },
        WAFType.AWS_WAF: {
            'headers': ['x-amzn-requestid', 'x-amz-cf-id', 'x-amz-cf-pop'],
            'cookies': ['awsalb', 'awsalbcors'],
            'server': [],
            'body_patterns': [r'aws', r'request blocked']
        },
        WAFType.AKAMAI: {
            'headers': ['akamai-x-cache', 'akamai-origin-hop', 'x-akamai-request-id'],
            'cookies': ['ak_bmsc', 'bm_sv', 'bm_mi'],
            'server': ['akamaighost'],
            'body_patterns': [r'akamai', r'reference #']
        },
        WAFType.INCAPSULA: {
            'headers': ['x-cdn', 'x-iinfo'],
            'cookies': ['incap_ses_', 'visid_incap_', '___utmvc'],
            'server': [],
            'body_patterns': [
                r'incapsula',
                r'imperva',
                r'request unsuccessful',
                r'incapsula incident id'
            ]
        },
        WAFType.MODSECURITY: {
            'headers': [],
            'cookies': [],
            'server': ['mod_security', 'modsecurity'],
            'body_patterns': [
                r'mod_security',
                r'this error was generated by mod_security',
                r'not acceptable'
            ]
        },
        WAFType.F5_BIG_IP: {
            'headers': ['x-wa-info', 'x-cnection'],
            'cookies': ['ts', 'bigipserver', 'f5', 'bigip'],
            'server': ['big-ip', 'bigip'],
            'body_patterns': [r'the requested url was rejected', r'bigip']
        },
        WAFType.BARRACUDA: {
            'headers': ['x-barracuda'],
            'cookies': ['barra_counter_session', 'barracuda_'],
            'server': ['barracuda'],
            'body_patterns': [r'barracuda', r'you have been blocked']
        },
        WAFType.FORTIWEB: {
            'headers': [],
            'cookies': ['fortiweb', 'fwsid'],
            'server': ['fortiweb'],
            'body_patterns': [r'fortinet', r'fortiweb', r'.fgd alert']
        },
        WAFType.CITRIX_NETSCALER: {
            'headers': ['ns-cache', 'x-client-ip', 'citrix-tid'],
            'cookies': ['ns_af', 'citrix_ns_id', 'nsc_'],
            'server': ['netscaler'],
            'body_patterns': [r'netscaler', r'citrix']
        },
        WAFType.RADWARE: {
            'headers': ['x-rad-ip'],
            'cookies': [],
            'server': [],
            'body_patterns': [r'radware', r'unauthorized activity']
        },
        WAFType.SUCURI: {
            'headers': ['x-sucuri-id', 'x-sucuri-cache'],
            'cookies': ['sucuri-'],
            'server': ['sucuri'],
            'body_patterns': [r'sucuri', r'access denied', r'blocked by sucuri']
        },
        WAFType.WORDFENCE: {
            'headers': [],
            'cookies': ['wfvt_', 'wordfence_'],
            'server': [],
            'body_patterns': [
                r'wordfence',
                r'generated by wordfence',
                r'this response was generated by wordfence'
            ]
        },
        WAFType.CLOUDFRONT: {
            'headers': ['x-amz-cf-id', 'x-amz-cf-pop', 'via'],
            'cookies': [],
            'server': ['cloudfront'],
            'body_patterns': [r'cloudfront', r'generated by cloudfront']
        },
        WAFType.AZURE_WAF: {
            'headers': ['x-azure-ref', 'x-msedge-ref'],
            'cookies': [],
            'server': ['azurewebsites'],
            'body_patterns': [r'azure', r'microsoft azure']
        },
        WAFType.SQREEN: {
            'headers': ['x-sqreen-id'],
            'cookies': ['sq', '_sqreen'],
            'server': [],
            'body_patterns': [r'sqreen', r'protected by sqreen']
        },
        WAFType.REBLAZE: {
            'headers': ['x-rb-id'],
            'cookies': ['rbzid'],
            'server': [],
            'body_patterns': [r'reblaze', r'access denied']
        },
        WAFType.WALLARM: {
            'headers': ['x-wallarm-'],
            'cookies': ['wallarm'],
            'server': [],
            'body_patterns': [r'wallarm', r'blocked by wallarm']
        }
    }
    
    def __init__(self):
        """Initialize WAF detector"""
        pass
    
    def detect(self, headers: Dict[str, str], cookies: Optional[Dict[str, str]] = None,
               body: Optional[str] = None, server_header: Optional[str] = None) -> WAFDetectionResult:
        """
        Detect WAF from HTTP response.
        
        Args:
            headers: HTTP response headers
            cookies: HTTP cookies (optional)
            body: Response body (optional)
            server_header: Server header value (optional)
            
        Returns:
            WAFDetectionResult with detection information
        """
        # Normalize headers and cookies
        normalized_headers = {k.lower(): v for k, v in headers.items()}
        cookie_names = set(cookies.keys() if cookies else [])
        body_lower = body.lower() if body else ""
        server_lower = (server_header or normalized_headers.get('server', '')).lower()
        
        detection_scores = {}
        detection_indicators = {}
        
        # Check each WAF signature
        for waf_type, signatures in self.WAF_SIGNATURES.items():
            score = 0
            indicators = []
            
            # Check headers
            for header in signatures['headers']:
                if header.lower() in normalized_headers:
                    score += 3
                    indicators.append(f"Header: {header}")
            
            # Check cookies
            for cookie_pattern in signatures['cookies']:
                for cookie_name in cookie_names:
                    if cookie_pattern.lower() in cookie_name.lower():
                        score += 2
                        indicators.append(f"Cookie: {cookie_name}")
            
            # Check server header
            for server_pattern in signatures['server']:
                if server_pattern in server_lower:
                    score += 4
                    indicators.append(f"Server: {server_pattern}")
            
            # Check body patterns
            if body:
                for pattern in signatures['body_patterns']:
                    if re.search(pattern, body_lower, re.IGNORECASE):
                        score += 1
                        indicators.append(f"Body pattern: {pattern}")
            
            if score > 0:
                detection_scores[waf_type] = score
                detection_indicators[waf_type] = indicators
        
        # Determine detected WAF
        if detection_scores:
            detected_waf = max(detection_scores, key=detection_scores.get)
            max_score = detection_scores[detected_waf]
            
            # Calculate confidence (normalized to 0-1)
            confidence = min(max_score / 10.0, 1.0)
            
            # Get recommendations
            recommendations = self._get_recommendations(detected_waf)
            
            result = WAFDetectionResult(
                detected=True,
                waf_type=detected_waf,
                confidence=confidence,
                indicators=detection_indicators[detected_waf],
                recommendations=recommendations,
                headers={k: v for k, v in normalized_headers.items() if any(
                    sig in k for sig in self.WAF_SIGNATURES[detected_waf]['headers']
                )},
                cookies=[c for c in cookie_names if any(
                    pattern.lower() in c.lower() for pattern in self.WAF_SIGNATURES[detected_waf]['cookies']
                )]
            )
            
            logger.info(f"WAF detected: {detected_waf.value} (confidence: {confidence:.2f})")
            
        else:
            result = WAFDetectionResult(
                detected=False,
                waf_type=WAFType.NONE,
                confidence=0.0,
                indicators=[],
                recommendations=[],
                headers={},
                cookies=[]
            )
            
            logger.debug("No WAF detected")
        
        return result
    
    def _get_recommendations(self, waf_type: WAFType) -> List[str]:
        """Get recommendations for dealing with a specific WAF"""
        recommendations_map = {
            WAFType.CLOUDFLARE: [
                "Respect rate limits to avoid challenges",
                "Use real browser User-Agent",
                "Maintain consistent request patterns",
                "Consider using residential proxies",
                "Handle JavaScript challenges if encountered"
            ],
            WAFType.AWS_WAF: [
                "Distribute requests across different IPs",
                "Use authentic browser headers",
                "Avoid triggering rate limit rules",
                "Respect robots.txt"
            ],
            WAFType.AKAMAI: [
                "Use rotating user agents carefully",
                "Implement proper retry logic",
                "Maintain session consistency",
                "Avoid aggressive scraping patterns"
            ],
            WAFType.INCAPSULA: [
                "Handle cookie-based challenges",
                "Use JavaScript rendering if needed",
                "Implement proper backoff strategies",
                "Consider premium proxy services"
            ],
            WAFType.MODSECURITY: [
                "Avoid SQL injection patterns in URLs",
                "Use clean, normal-looking requests",
                "Avoid suspicious payloads",
                "Implement proper error handling"
            ],
            WAFType.F5_BIG_IP: [
                "Maintain consistent session cookies",
                "Avoid triggering bot detection",
                "Use realistic request timing",
                "Handle challenges gracefully"
            ]
        }
        
        return recommendations_map.get(waf_type, [
            "Use realistic browser behavior",
            "Implement proper rate limiting",
            "Respect the website's terms of service",
            "Consider reaching out to site owners for API access"
        ])
    
    def get_all_supported_wafs(self) -> List[WAFType]:
        """Get list of all supported WAF types"""
        return list(self.WAF_SIGNATURES.keys())


def detect_waf(headers: Dict[str, str], cookies: Optional[Dict[str, str]] = None,
               body: Optional[str] = None) -> WAFDetectionResult:
    """
    Convenience function to detect WAF.
    
    Args:
        headers: HTTP response headers
        cookies: HTTP cookies (optional)
        body: Response body (optional)
        
    Returns:
        WAFDetectionResult
    """
    detector = WAFDetector()
    return detector.detect(headers, cookies, body)




